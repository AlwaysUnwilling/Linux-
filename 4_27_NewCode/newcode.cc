#include<iostream>
#include<string>


using namespace std;

//【星际密码】
/*
 *星际战争开展了100年之后，NowCoder终于破译了外星人的密码！他们的密码是一串整数，通过一张表里的信息映射成最终4位密码。表的规则是：n
对应的值是矩阵X的n次方的左上角，如果这个数不足4位则用0填充，如果大于4位的则只输出最后4位。
|1 1|^n => |Xn ..|
|1 0| |.. ..|
例如n=2时，
|1 1|^2 => |1 1| * |1 1| => |2 1|
|1 0| |1 0| |1 0| |1 1|
即2对应的数是“0002”。
 * */


/*
 *|a,b|*|e,f|                                  |1,1|
  |c,d| |g,h|的左上角的值等于ae+bg 通过计算等到|1,0|的n次方左上角值依次是1,2,3,5,8,13，...
  满足斐波那契数，因此输入数字num对应的是斐波那契的项数对应的值，当该值超过4位数时需要保留低四位，即对该数字取
  10000MOD，低于四位的数字高位补0
 * */
int main()
{
  //生成斐波那契数组
  int f_arr[10000]={0,1,2,3};
  for(int i=4;i<=10000;++i){
    f_arr[i]=f_arr[i-1]+f_arr[i-2];
  }
  int n=0;
  while(cin>>n){
    for(int i=0;i<n;++i){
      int tmp=0;
      cin>>tmp;
      tmp=f_arr[tmp]%10000;
      printf("%04d",tmp);
    }
    cout<<endl;
  }
  return 0;
}

//【数根】
/*
 *数根可以通过把一个数的各个位上的数字加起来得到。如果得到的数是一位数，那么这个数就是数根；如果结果是两位数或者包括更多位的数字，那么再把
这些数字加起来。如此进行下去，直到得到是一位数为止。
比如，对于24 来说，把2 和4 相加得到6，由于6 是一位数，因此6 是24 的数根。
再比如39，把3 和9 加起来得到12，由于12 不是一位数，因此还得把1 和2 加起来，最后得到3，这是一个一位数，因此3 是39 的数根。
现在给你一个正整数，输出它的数根。
输入包含多组数据。
每组数据数据包含一个正整数n（1≤n≤10E1000）。
 * */


//由于输入的数字可能非常大，超过int的接收范围，因此需要使用string来接收

int GetNumRoot(const string& n)
{
  int tmp=0;
  while(tmp==0){
    for(auto& e:n){
      tmp+=e-'0';
    }
    if(tmp/10){
      n=to_string(tmp);
      tmp=0;
    }else{
      break;
    }
  }
  return tmp;
}
int main()
{
  string n;
  while(cin>>n){
    cout<<GetNumRoot(n)<<endl;
  }
  return 0;
}
